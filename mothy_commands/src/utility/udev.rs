use crate::{Context, Error};

use std::fmt::Write;

use poise::CreateReply;
use poise::serenity_prelude::{CreateAttachment, CreateEmbed};
use serenity::all::Colour;

/// Generates OpenTabletDriver udev rules for the given vendor and product Ids.
#[poise::command(
    rename = "generate-udev",
    aliases("udev"),
    slash_command,
    prefix_command
)]
pub async fn generate_udev(
    ctx: Context<'_>,
    #[description = "The Vendor Id in decimal."] vendor_id: u64,
    #[description = "The Product Id in decimal."] product_id: u64,
    libinput_override: Option<bool>,
) -> Result<(), Error> {
    let udev = gen_udev(vendor_id, product_id, libinput_override.unwrap_or(true));

    ctx.send(udev_reply(udev)).await?;

    Ok(())
}

/// Generates OpenTabletDriver udev rules for the given vendor and product Ids in hex.
#[poise::command(
    rename = "generate-udev-hex",
    aliases("udev-hex"),
    slash_command,
    prefix_command
)]
pub async fn generate_udev_hex(
    ctx: Context<'_>,
    #[description = "The Vendor Id in hex."] vendor_id: String,
    #[description = "The Product Id in hex."] product_id: String,
    libinput_override: Option<bool>,
) -> Result<(), Error> {
    let hex_replacements = ["#", "0x"];
    let vendor_id_hex_parsed = u64::from_str_radix(
        &hex_replacements
            .iter()
            .fold(vendor_id, |acc, x| acc.replacen(x, "", 1)),
        16,
    );
    let product_id_hex_parsed = u64::from_str_radix(
        &hex_replacements
            .iter()
            .fold(product_id, |acc, x| acc.replacen(x, "", 1)),
        16,
    );
    if let Ok(vendor_id_decimal) = vendor_id_hex_parsed
        && let Ok(product_id_decimal) = product_id_hex_parsed
    {
        let udev = gen_udev(
            vendor_id_decimal,
            product_id_decimal,
            libinput_override.unwrap_or(true),
        );

        ctx.send(udev_reply(udev)).await?;
    } else {
        ctx.send(poise::CreateReply::new().content(format!("Could not parse udev hex input")))
            .await?;
    }

    Ok(())
}

const REQUIRED_UDEV_STR: &str = r#"
KERNEL=="uinput", SUBSYSTEM=="misc", OPTIONS+="static_node=uinput", TAG+="uaccess", TAG+="udev-acl"
KERNEL=="js[0-9]*", SUBSYSTEM=="input", ATTRS{name}=="OpenTabletDriver Virtual Tablet", RUN+="/usr/bin/env rm %E{DEVNAME}"
"#;

fn gen_udev(id_vendor: u64, id_product: u64, libinput_override: bool) -> String {
    let mut udev_rules = format!(
        "KERNEL==\"hidraw*\", ATTRS{{idVendor}}==\"{id_vendor:04x}\", \
         ATTRS{{idProduct}}==\"{id_product:04x}\", TAG+=\"uaccess\", \
         TAG+=\"udev-acl\"\nSUBSYSTEM==\"usb\", ATTRS{{idVendor}}==\"{id_vendor:04x}\", \
         ATTRS{{idProduct}}==\"{id_product:04x}\", TAG+=\"uaccess\", TAG+=\"udev-acl\""
    );

    if libinput_override {
        write!(
            udev_rules,
            "\nSUBSYSTEM==\"input\", ATTRS{{idVendor}}==\"{id_vendor:04x}\", \
             ATTRS{{idProduct}}==\"{id_product:04x}\", ENV{{LIBINPUT_IGNORE_DEVICE}}=\"1\""
        )
        .unwrap();
    }

    format!("{REQUIRED_UDEV_STR}\n# Generated by TabletBot\n{udev_rules}")
}

fn udev_reply(udev: String) -> CreateReply<'static> {
    let attachment = CreateAttachment::bytes(udev, "70-opentabletdriver.rules");
    let embed = CreateEmbed::new()
        .title("Generated udev rules")
        .description(
            "Move this file to `/etc/udev/rules.d/70-opentabletdriver.rules` then run the \
             following commands: \n```sudo udevadm control --reload-rules && sudo udevadm \
             trigger\n```",
        )
        .color(Colour(0x2ecc71));

    return CreateReply::default().embed(embed).attachment(attachment);
}

#[must_use]
pub fn commands() -> [crate::Command; 2] {
    [generate_udev(), generate_udev_hex()]
}
